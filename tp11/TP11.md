# TP11

## Objectifs

- Toujours plus de templates
- Perfect forwarding
- SFINAE

## Exercice 1 : Entity factory

Une factory est un design pattern permettant d'instancier des objets sans connaître leur classe (sinon la classe abstraite dont ils héritent).
Il se découpe en une première phase pour enregistrer les constructeur en leur associant un identifiant (chaine de caractère ici).

1. Compléter la classe `Factory` :
   
   1. Définir un type `Builder` représentant une fonction construisant un objet `Entity`.
   
   2. Ajouter un membre associant un identifiant à un `Builder`
   
   3. Compléter la méthode template `register_entity` qui crée et enregistre un `Builder` pour le type en template
   
   4. Compléter la méthode `build`
    
2. Tester avec la classe `Object`.

3. Compléter et tester avec la classe `Tree` afin de produire la sortie :
   ```shell
   Object
   Tree
   ```

4. Compléter les classes `Person`, `Animal`. Ces deux classes respectent les contraintes analogues suivantes :
   1. Une personne porte un nom
   2. Un animal est caractérisé par une espèce

5. Si ce n'est pas déjà le cas, adapter la méthode `register_entity` afin de pouvoir spécifier les arguments qui seront utilisés pour la création de chaque entité.
   Par exemple, l'identifiant `"Dog"` permettra de créer un `Animal` d'espèce `"Dog"`.
   Le choix du nom pour l'identifiant `"Person"` est laissé au développeur.

6. Compléter la classe `House` en sachant qu'une maison est possédée par une personne de type `Person` déterminé à sa construction. 

7. S'assurer que la `Factory` permet de construire une maison d'une personne prédéfinie.

## Exercice 2 : Une fonction to_string générique

L'objectif de cette exercice est l'écriture une fonction générique permettant la conversion d'une donnée en une chaine de caractère.
On s'appuiera pour ça sur le mécanisme SFINAE.

On propose une version de base peut dont la sortie est peu clair et comporte un nom proche de celui du type de la donnée, et l'adresse de la donnée.

```cpp
template <typename T>
auto to_string(const T& data)
{
    std::stringstream ss;
    ss << "<" << typeid(data).name() << ": " << &data << ">";
    return ss.str();
}
```

Afin d'améliorer cette fonction, on va se baser sur :
- la conversion directe depuis un `char*`
- la conversion des nombres fournie par `std::to_string`
- l'inspection des conteneurs de la bibliothèque standard
- l'éventuelle existence d'une méthode `to_string` de l'objet qu'on souhaite convertir
- l'éventuelle existence d'un opérateur de flux

1. Ajouter les spécialisations pour les types `std::string` et `char*`

2. Ajouter une spécialisation pour les types pour lesquels la fonction `std::to_string` existe.

   Cette ajout provoque (probablement) une ambiguïté lors de l'appel à `to_string` sur un entier.
   On doit artificiellement mettre un ordre de préférence entre les multiples choix.

3. Sachant que le compilateur choisit la fonction dont la signature indique le moins de conversion, proposer une solution à ce problème.

4. Ajouter une spécialisation pour les conteneurs, on affichera une paire d'accolades encadrant leurs contenus.

   _Note_: On pourra utiliser l'opérateur séquence/_comma_ avec l'opérateur `decltype`, par exemple `decltype(exp1, exp2, std::string())` renvoie le type `std::string` (si les expressions ne provoquent pas d'_échec_). 
   Cela permet entre autres de spécifier plusieurs conditions lors d'une spécialisation d'une fonction template.

5. Ajouter une spécialisation pour les classes possédant une méthode `to_string`

6. Ajouter une spécialisation pour les classes possédant un opérateur de flux.

   À nouveau, une ambiguïté peut se produire ici si une classe possède à la fois la méthode `to_string` et l'opérateur de flux.
   La résolution précédente peut être à nouveau utilisée.

7. (**bonus**) Ajouter une spécialisation pour les tuples.
   Comme on ne peut pas itérer simplement sur un tuple, il faut ruser, en utilisant notamment le type [`std::integer_sequence`](https://en.cppreference.com/w/cpp/utility/integer_sequence). 