#include <catch2/catch_test_macros.hpp>
#include "../../lib/InstanceCounter.hpp"
#include "../../src/uge_unique_ptr.hpp"

#include <iostream>

//          vvvvvvvvvvvvvvv note that ABR derives from InstanceCounter
class ABR : InstanceCounter
{
public:
    ABR(int label) : _label{label} {}

    void insert(int i)
    {
        if (i == _label)
            return;
        else
        {
            uge::unique_ptr<ABR> &child = (i < _label) ? left : right;
            if (child.get() == nullptr)
                child = new ABR{i};
            //       ^^^
            // For this file to compile, you need to define this assignment operator
            else
                (*child).insert(i);
        }
    }

private:
    uge::unique_ptr<ABR> left{nullptr};
    uge::unique_ptr<ABR> right{nullptr};
    int _label;
};

TEST_CASE("a. `ABR` is automatically copiable.")
{
    InstanceCounter::reset_counters();
    {
        ABR t{4};
        t.insert(2);
        t.insert(6);
        t.insert(1);
        t.insert(3);
        t.insert(5);
        t.insert(7);
        // `t` is the complete binary tree of height 2: hence has 7 nodes
        REQUIRE(InstanceCounter::count() == 7);

        ABR copy_of_t = t; // The copy-construtor ABR(const ABR &) was automatically
                           // generated by the compiler and works as intended:
        REQUIRE(InstanceCounter::count() == 14);
    }
    REQUIRE(InstanceCounter::count() == 0);
}

TEST_CASE("b. `ABR` is automatically movable.")
{
    InstanceCounter::reset_counters();
    {
        ABR t{4};
        t.insert(2);
        t.insert(6);
        t.insert(1);
        t.insert(3);
        t.insert(5);
        t.insert(7);
        REQUIRE(InstanceCounter::count() == 7);

        ABR copy_of_t = std::move(t); // The move-construtor ABR(ABR &&) was automatically
                                      // generated by the compiler
        REQUIRE(InstanceCounter::count() == 8);
        // Oo why 8??  think about it       ^
    }
    REQUIRE(InstanceCounter::count() == 0);
}