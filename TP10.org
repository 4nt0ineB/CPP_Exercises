#+TITLE: Heu oui les templates
#+subtitle: Bienvenue en enfer


* Un template c'est quoi?
C'est un truc pour la généricité cf cours
* But de ce TP
Les images sont des tableaux de *pixels*.
On va utiliser des templates pour définir des images de taille statique utilisant plusieurs types de pixels.

+ implémenter des pixels
+ implémenter des images
+ implémenter un opérateur entre 2 images qui fait des trucs en fonction du type de pixel
+ conversion de pixels
+ conversions d'images
| A    | B    | effet                  | Type sortant |
|------+------+------------------------+--------------|
| any  | Luma | masque de transparence | RGBA         |
| any  | RGBA | blending               | RGBA         |
| RGBA | RGB  | blending               | RGBA         |
| RGB  | RGB  | blending               | RGB          |
| Luma | RGB  | blending               | RGB          |
  
* Les tests pas à pas
** TODO Test 01: Image
On travaillera dans image.hpp

On définit une classe template ~Image<typename P, size_t W, size_t H>~ où (W,H) est la dimension de l'image et P le type utilisé pour les pixels (au début on utilisera des entiers simples).
Attention, l'image doît être stockée en *colones* et pas en *lignes*.
Utilisez des std::array<> pour stocker les pixels.

On doit avoir:
+ un constructeur ~Image(const P & pix)~ prenant un pixel de remplissage et construisant une image unie
+ un constructeur par défault ~Image()~ utilisant le constructeur précédent

On veut aussi pouvoir utiliser img(i,j) pour accéder au pixel de la j-ème ligne et de la i-ème colone, on va pour cela implémenter:
+ ~P & operator(const size_t i, const size_t j)~
+ ~const P & operator(const size_t i, const size_t j) const~

Ensuite, on veux pouvoir additioner deux image de même tailles, en additionants les pixels un par un.
Ainsi on aura \((img_1 + img_2)(i,j) = img_1(i,j) + img_2(i,j)\).
Overloadez l'opérateur + hors de la classe, ça sera plus facile pour la suite.
  
** TODO Test 02: Image IO
Avant toute chose, on va ajouter un nouveau constructeur:
#+begin_src c++
    Image<P, W, H>(const std::function<P(const size_t i, const size_t j)> & functor)
    {
        // todo
    }
#+end_src

Où functor(i,j) est une valeur de pixel à mettre en (i,j).

Ensuite, vous allez simplement ajouter les deux méthodes suivantes à Image:
#+begin_src c++
    Image<P, W, H>(const std::string & path)
    {
        int w, h, c;
        const uint8_t * data = stbi_load(path.c_str(),
                                         &w, &h, &c, 0);
        if(data == NULL)
        {
            std::cout << "Could not find image '" << path << "'" << std::endl;
            exit(1);
        }
        else if (w!=W || h != H || c != sizeof(P))
        {
            std::cout << "Could not open image '"
                      << path << "' with the dimensions ("
                      << W <<"," << H << ","
                      << sizeof(P)<<"), found ("
                      << w <<","<<h<<","<< c  << ")" << std::endl;
        }
        else
        {
            for (size_t i = 0; i < W; ++i)
            {
                for (size_t j = 0; j < H; ++j)
                {
                    const uint8_t * pixel_ptr = data + ((j%h)*w + (i%w))*c;
                    (*this)(i,j) = *reinterpret_cast<const P *>(pixel_ptr);
                }
            }
        }
    }
    
    void
    save(const std::string & path) const
    {
        const auto data = reinterpret_cast<const uint8_t *>(this);
        stbi_write_png(path.c_str(), W, H, sizeof(P), data, W*sizeof(P));
    }
        

#+end_src

Ne perdez pas trop de temps à lire ces fonctions: on s'en fout et vous ne travaillez pas sur ce sujet aujourd'hui.

Maintennant vous pouvez lire et écrire des images, et même générer procéduralement des images.


** TODO Test 03: Procedural Images
Ici rien à faire, regardez juste les images générées dans build/images.
(ne confondez pas avec le dossier images à la racine de votre projet).

** TODO Test 04: Pixels
On va définir nos propres types de pixels: les ~struct~ RGBA, RGB, et Luma.
|      | Nombre de canaux/taille en octets   | Description           |
|------+-------------------------------------+-----------------------|
| RGBA |                                   4 | Rouge,Vert,Bleu,Alpha |
| RGB  |                                   3 | Rouge,Vert,Bleu       |
| Luma |                                   1 | Niveau de Gris        |

Implémentez ces trois ~struct~, en utilisant le type uint8_t ou unsigned char pour les valeurs des canaux.

On va ensuite vouloir *convertir* les pixels entre eux.
On va donc créer une fonction template

#+begin_src c++
template<typename A, typename B>
A from(const B & stuff);
#+end_src

On va se baser sur ce principe: on peut tout convertir en RGBA, et on peut convertir RGBA en tout.
Commencez par implémenter dans l'ordre:
+ la conversion RGBA => RGBA (cas trivial)
+ la conversion RGBA => RGB
+ la conversion RGBA => Luma
+ la conversion RGB  => RGBA
+ la conversion Luma => RGBA

Ensuite, implémentez un cas plus général

#+begin_src c++
template<typename A, typename B>
A from(const B & stuff)
{
    // TODO
}
#+end_src

Où vous convertirez le type B en RGBA, puis le RGBA en type A.

Implémentez ensuite ~B into<A,B>(const A &)~, qui fait la même chose que ~from<B,A>~ (ça se fait en une seule fois).



** TODO Test 06: Blending
On veut pouvoir additioner les différents pixels qu'on a définit pour pouvoir combiner des images.
On peut:
+ soit “blender„ les couleurs de deux pixels (en utilisant la fonction mix_color de la lib du TP)
+ soit se servir de l'image de droite comme masque de transparence.
  # METTRE Images d'exemple.
On va se baser sur ce tableau pour savoir quoi faire:
| A    | B    | effet                  | Type sortant C |
|------+------+------------------------+----------------|
| tout | Luma | masque de transparence | RGBA           |
| tout | RGBA | blending               | RGBA           |
| RGBA | RGB  | blending               | RGBA           |
| RGB  | RGB  | blending               | RGB            |
| Luma | RGB  | blending               | RGB            |


*** color blending
Écrivez une fonction ~blend_two_rgba~ qui prend deux RGBA et les blend en utilisant mix_color.

Ensuite, vous pouvez utiliser cette fonction pour implémenter tous les ~C operator+(const A & lhs, const B & rhs)~ nécessaires.

Astuce: vous pouvez vous arranger écrire une macro avec ~#define~ pour ne pas avoir à réécrire 6 fois la même fonction.

Vous auriez quelque chose comme ça:
#+begin_src c++
IMPL_ADD(RGBA, RGBA, RGBA);
IMPL_ADD(RGBA, RGB , RGBA);
IMPL_ADD(RGB , RGBA, RGB );
IMPL_ADD(Luma, RGBA, RGBA);
IMPL_ADD(Luma, RGB , RGB);
IMPL_ADD(RGB , RGB , RGB);
#+end_src


*** Luma as alpha mask

Pour celle-là, il suffit d'écrire que cette fonction template sans spécialisation:
#+begin_src c++
// mask operator
template<typename A>
RGBA
operator+(const A    & lhs,
          const Luma & mask)
{
    // todo
}
#+end_src

Il est attendu que la sortie soit toujours du RGBA (vu que c'est le seul type de pixel ayant de la transparence).
La valeur alpha de la sortie sera celle de lhs fois la valeur de gris de mask, le tout divisé par 255.

Normalement à ce stade, il manque une chose: revenez à Image et regardez l'opérateur+
#+begin_src c++
template<const size_t W, const size_t H, typename A, typename B>
Image<A, W, H>
operator+(const Image<A, W, H> & lhs, const Image<B, W, H> & rhs)
{
    // des trucs
}
#+end_src
Remarquez que le type de retour est le même que le type à gauche. Hors on veut ajouter ces exceptions:

| A    | B    | Sortie |
|------+------+--------|
| tout | Luma | RGBA   |

Il suffit de rajouter une spécialisation de l'opérateur + de image.


À ce stade, vous pouvez regarder les images générées dans build/images: votre code produit des montages à partir des fonctionalitées que vous avez implémenté!


